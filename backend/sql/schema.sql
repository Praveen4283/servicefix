-- Extensions
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- Organizations table
CREATE TABLE IF NOT EXISTS organizations (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  domain VARCHAR(255) NOT NULL,
  logo_url VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Users table
CREATE TABLE IF NOT EXISTS users (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  email VARCHAR(255) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  first_name VARCHAR(100) NOT NULL,
  last_name VARCHAR(100) NOT NULL,
  organization_id BIGINT REFERENCES organizations(id) ON DELETE SET NULL,
  role VARCHAR(50) NOT NULL DEFAULT 'customer', -- admin, agent, customer
  avatar_url TEXT,
  phone VARCHAR(50),
  timezone VARCHAR(100) DEFAULT 'UTC',
  language VARCHAR(10) DEFAULT 'en',
  is_active BOOLEAN DEFAULT TRUE,
  last_login_at TIMESTAMP WITH TIME ZONE,
  reset_token VARCHAR(255),
  reset_token_expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  designation VARCHAR(100)
);

-- User tokens table (Using BIGINT for PK, keeping FK as BIGINT)
CREATE TABLE IF NOT EXISTS user_tokens (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  refresh_token VARCHAR(255) NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  is_revoked BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Departments table
CREATE TABLE IF NOT EXISTS departments (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  organization_id BIGINT REFERENCES organizations(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, name)
);

-- Department members
CREATE TABLE IF NOT EXISTS department_members (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  department_id BIGINT NOT NULL REFERENCES departments(id) ON DELETE CASCADE,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  is_manager BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Ticket priorities
CREATE TABLE IF NOT EXISTS ticket_priorities (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  color VARCHAR(7) NOT NULL,
  sla_hours INTEGER NOT NULL,
  organization_id BIGINT REFERENCES organizations(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, name)
);

-- Ticket statuses
CREATE TABLE IF NOT EXISTS ticket_statuses (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  color VARCHAR(7) NOT NULL,
  is_default BOOLEAN NOT NULL DEFAULT FALSE,
  is_resolved BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, name),
  EXCLUDE USING gist (organization_id WITH =) WHERE (is_default)
);

-- Ticket types
CREATE TABLE IF NOT EXISTS ticket_types (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  organization_id BIGINT REFERENCES organizations(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, name)
);

-- Tags
CREATE TABLE IF NOT EXISTS tags (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(100) NOT NULL,
  color VARCHAR(7) NOT NULL,
  organization_id BIGINT REFERENCES organizations(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, name)
);

-- Tickets table
CREATE TABLE IF NOT EXISTS tickets (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  subject VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  requester_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  assignee_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
  department_id BIGINT REFERENCES departments(id) ON DELETE SET NULL,
  priority_id BIGINT REFERENCES ticket_priorities(id) ON DELETE SET NULL,
  status_id BIGINT NOT NULL REFERENCES ticket_statuses(id) ON DELETE RESTRICT,
  type_id BIGINT REFERENCES ticket_types(id) ON DELETE SET NULL,
  organization_id BIGINT REFERENCES organizations(id) ON DELETE CASCADE,
  due_date TIMESTAMP WITH TIME ZONE,
  sentiment_score DECIMAL(3,2),
  ai_summary TEXT,
  source VARCHAR(50) DEFAULT 'web', -- web, email, chat, phone, etc.
  is_spam BOOLEAN DEFAULT FALSE,
  parent_ticket_id BIGINT REFERENCES tickets(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  resolved_at TIMESTAMP WITH TIME ZONE,
  closed_at TIMESTAMP WITH TIME ZONE,
  sla_status VARCHAR(50),
  first_response_sla_breached BOOLEAN DEFAULT FALSE,
  resolution_sla_breached BOOLEAN DEFAULT FALSE
);

-- Ticket tags
CREATE TABLE IF NOT EXISTS ticket_tags (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  ticket_id BIGINT NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(ticket_id, tag_id)
);

-- Ticket comments
CREATE TABLE IF NOT EXISTS ticket_comments (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  ticket_id BIGINT NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  is_internal BOOLEAN DEFAULT FALSE,
  is_system BOOLEAN DEFAULT FALSE,
  sentiment_score DECIMAL(3,2),
  parent_comment_id BIGINT REFERENCES ticket_comments(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Ticket attachments
CREATE TABLE IF NOT EXISTS ticket_attachments (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  ticket_id BIGINT NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,
  comment_id BIGINT REFERENCES ticket_comments(id) ON DELETE CASCADE,
  file_name VARCHAR(255) NOT NULL,
  file_path VARCHAR(255) NOT NULL,
  file_type VARCHAR(100),
  file_size INT,
  uploaded_by BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Ticket history/audit log
CREATE TABLE IF NOT EXISTS ticket_history (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  ticket_id BIGINT NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,
  user_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
  field_name VARCHAR(100) NOT NULL,
  old_value TEXT,
  new_value TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- SLA policies
CREATE TABLE IF NOT EXISTS sla_policies (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  ticket_priority_id BIGINT NOT NULL REFERENCES ticket_priorities(id) ON DELETE CASCADE,
  first_response_hours INT,
  next_response_hours INT,
  resolution_hours INT,
  business_hours_only BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(organization_id, ticket_priority_id)
);

-- SLA policy tickets
CREATE TABLE IF NOT EXISTS sla_policy_tickets (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  ticket_id BIGINT NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,
  sla_policy_id BIGINT NOT NULL REFERENCES sla_policies(id) ON DELETE CASCADE,
  first_response_due_at TIMESTAMP WITH TIME ZONE,
  next_response_due_at TIMESTAMP WITH TIME ZONE,
  resolution_due_at TIMESTAMP WITH TIME ZONE,
  first_response_met BOOLEAN,
  next_response_met BOOLEAN,
  resolution_met BOOLEAN,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  metadata JSONB,
  CONSTRAINT unique_ticket_sla_policy UNIQUE (ticket_id)
);

-- Comment on metadata column
COMMENT ON COLUMN sla_policy_tickets.metadata IS 'JSON structure containing: {pausePeriods: [{startedAt: Date, endedAt: Date}], totalPausedTime: number}';

-- Comment on unique constraint
COMMENT ON CONSTRAINT unique_ticket_sla_policy ON sla_policy_tickets IS 'Ensures each ticket has only one SLA policy assigned at a time to prevent conflicts';

-- Automation rules
CREATE TABLE IF NOT EXISTS automation_rules (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  conditions JSONB NOT NULL,
  actions JSONB NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  execution_order INT DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Knowledge base categories
CREATE TABLE IF NOT EXISTS kb_categories (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  slug VARCHAR(255) NOT NULL,
  parent_id BIGINT REFERENCES kb_categories(id) ON DELETE CASCADE,
  icon VARCHAR(50),
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  is_private BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Knowledge base articles
CREATE TABLE IF NOT EXISTS kb_articles (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  title VARCHAR(255) NOT NULL,
  slug VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  excerpt TEXT,
  category_id BIGINT REFERENCES kb_categories(id) ON DELETE SET NULL,
  author_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  status VARCHAR(50) DEFAULT 'published', -- draft, published, archived
  is_featured BOOLEAN DEFAULT FALSE,
  view_count INT DEFAULT 0,
  helpful_count INT DEFAULT 0,
  not_helpful_count INT DEFAULT 0,
  ai_summary TEXT,
  ai_search_vector tsvector,
  meta_title VARCHAR(255),
  meta_description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  published_at TIMESTAMP WITH TIME ZONE
);

-- KB article tags
CREATE TABLE IF NOT EXISTS kb_article_tags (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  article_id BIGINT NOT NULL REFERENCES kb_articles(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(article_id, tag_id)
);

-- Canned responses
CREATE TABLE IF NOT EXISTS canned_responses (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
  department_id BIGINT REFERENCES departments(id) ON DELETE CASCADE,
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  is_shared BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Canned response tags
CREATE TABLE IF NOT EXISTS canned_response_tags (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  canned_response_id BIGINT NOT NULL REFERENCES canned_responses(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(canned_response_id, tag_id)
);

-- Customer satisfaction survey
CREATE TABLE IF NOT EXISTS satisfaction_surveys (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  ticket_id BIGINT NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  rating INT NOT NULL, -- 1-5
  feedback TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Reports
CREATE TABLE IF NOT EXISTS saved_reports (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  report_type VARCHAR(100) NOT NULL,
  parameters JSONB NOT NULL,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  is_shared BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notifications
CREATE TABLE IF NOT EXISTS notifications (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  message TEXT NOT NULL,
  link VARCHAR(255),
  is_read BOOLEAN DEFAULT FALSE,
  is_deleted BOOLEAN DEFAULT FALSE,
  type VARCHAR(50) NOT NULL, -- ticket_assigned, ticket_updated, mention, etc.
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- User notification preferences
CREATE TABLE IF NOT EXISTS notification_preferences (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  event_type VARCHAR(50) NOT NULL, -- ticket_assigned, ticket_updated, mention, etc.
  email_enabled BOOLEAN DEFAULT TRUE,
  push_enabled BOOLEAN DEFAULT TRUE,
  in_app_enabled BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, event_type)
);

-- Chatbot conversations
CREATE TABLE IF NOT EXISTS chatbot_conversations (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  user_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
  visitor_id VARCHAR(255),
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  status VARCHAR(50) DEFAULT 'active', -- active, transferred, ended
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  ended_at TIMESTAMP WITH TIME ZONE
);

-- Chatbot messages
CREATE TABLE IF NOT EXISTS chatbot_messages (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  conversation_id BIGINT NOT NULL REFERENCES chatbot_conversations(id) ON DELETE CASCADE,
  sender_type VARCHAR(50) NOT NULL, -- user, bot, agent
  sender_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
  content TEXT NOT NULL,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- AI training data
CREATE TABLE IF NOT EXISTS ai_training_data (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  data_type VARCHAR(50) NOT NULL, -- sentiment, classification, entity, etc.
  input_text TEXT NOT NULL,
  output_labels JSONB NOT NULL,
  is_verified BOOLEAN DEFAULT FALSE,
  verified_by BIGINT REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Scheduled maintenance
CREATE TABLE IF NOT EXISTS scheduled_maintenance (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  title VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  start_time TIMESTAMP WITH TIME ZONE NOT NULL,
  end_time TIMESTAMP WITH TIME ZONE NOT NULL,
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  created_by BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  status VARCHAR(50) DEFAULT 'scheduled', -- scheduled, in_progress, completed, cancelled
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Settings Table
CREATE TABLE IF NOT EXISTS settings (
    id SERIAL PRIMARY KEY,
    category VARCHAR(50) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    -- General Settings
    company_name VARCHAR(255),
    support_email VARCHAR(255),
    max_file_size VARCHAR(50),
    default_time_zone VARCHAR(100),
    allow_guest_tickets BOOLEAN DEFAULT TRUE,
    -- Email Settings
    smtp_server VARCHAR(255),
    smtp_port INTEGER,
    smtp_username VARCHAR(255),
    smtp_password VARCHAR(255),
    email_from_name VARCHAR(255),
    email_reply_to VARCHAR(255),
    enable_email_notifications BOOLEAN DEFAULT TRUE,
    -- Ticket Settings
    default_priority VARCHAR(50),
    closed_ticket_reopen INTEGER,
    auto_close_resolved INTEGER,
    enable_customer_satisfaction BOOLEAN DEFAULT TRUE,
    require_category BOOLEAN DEFAULT TRUE,
    -- Integration Settings
    slack_enabled BOOLEAN DEFAULT FALSE,
    slack_webhook_url VARCHAR(255),
    slack_channel VARCHAR(100),
    slack_notify_on_new_ticket BOOLEAN DEFAULT TRUE,
    slack_notify_on_ticket_updates BOOLEAN DEFAULT FALSE,
    teams_enabled BOOLEAN DEFAULT FALSE,
    teams_webhook_url VARCHAR(255),
    teams_notify_on_new_ticket BOOLEAN DEFAULT TRUE,
    teams_notify_on_ticket_updates BOOLEAN DEFAULT FALSE,
    jira_enabled BOOLEAN DEFAULT FALSE,
    jira_url VARCHAR(255),
    jira_username VARCHAR(255),
    jira_api_token VARCHAR(255),
    jira_project VARCHAR(100),
    jira_create_issues_for_tickets BOOLEAN DEFAULT TRUE,
    github_enabled BOOLEAN DEFAULT FALSE,
    github_access_token VARCHAR(255),
    github_repository VARCHAR(255),
    github_create_issues_for_tickets BOOLEAN DEFAULT TRUE,
    -- Advanced Settings
    api_enabled BOOLEAN DEFAULT TRUE,
    api_rate_limit_per_hour INTEGER DEFAULT 1000,
    api_rate_limit_window_minutes INTEGER DEFAULT 15,
    enable_api_documentation BOOLEAN DEFAULT TRUE,
    max_login_attempts INTEGER DEFAULT 5,
    password_expiry_days INTEGER DEFAULT 90,
    session_timeout_minutes INTEGER DEFAULT 60,
    enforce_mfa BOOLEAN DEFAULT FALSE,
    cache_duration_minutes INTEGER DEFAULT 15,
    max_concurrent_file_uploads INTEGER DEFAULT 5,
    enable_custom_fields BOOLEAN DEFAULT TRUE,
    max_custom_fields_per_ticket INTEGER DEFAULT 10,
    enable_ai_suggestions BOOLEAN DEFAULT TRUE,
    enable_auto_tagging BOOLEAN DEFAULT TRUE,
    enable_sentiment_analysis BOOLEAN DEFAULT TRUE,
    ai_model_name VARCHAR(100),
    ai_provider VARCHAR(50),
    ai_api_key VARCHAR(255)
);

-- Create unique constraint on category
CREATE UNIQUE INDEX IF NOT EXISTS idx_settings_category ON settings (category);

-- Add initial default email settings
INSERT INTO settings (
    category, 
    smtp_server, smtp_port, smtp_username, smtp_password, 
    email_from_name, email_reply_to, enable_email_notifications
) 
VALUES (
    'email', 
    'smtp.example.com', 587, 'username', 'password_placeholder', 
    'ServiceFix Support', 'support@example.com', true
)
ON CONFLICT (category) DO NOTHING;

-- Add initial default general settings
INSERT INTO settings (
    category, 
    company_name, support_email, max_file_size, 
    allow_guest_tickets, default_time_zone
) 
VALUES (
    'general', 
    'ServiceFix', 'support@servicefix.com', '5', 
    true, 'UTC'
)
ON CONFLICT (category) DO NOTHING;

-- Add initial default ticket settings
INSERT INTO settings (
    category, 
    default_priority, closed_ticket_reopen, auto_close_resolved, 
    enable_customer_satisfaction, require_category
) 
VALUES (
    'ticket', 
    'medium', 7, 3, 
    true, true
)
ON CONFLICT (category) DO NOTHING;

-- Add initial default integration settings
INSERT INTO settings (
    category, 
    slack_enabled, slack_webhook_url, slack_channel, slack_notify_on_new_ticket, slack_notify_on_ticket_updates,
    teams_enabled, teams_webhook_url, teams_notify_on_new_ticket, teams_notify_on_ticket_updates,
    jira_enabled, jira_url, jira_username, jira_api_token, jira_project, jira_create_issues_for_tickets,
    github_enabled, github_access_token, github_repository, github_create_issues_for_tickets
) 
VALUES (
    'integration', 
    false, '', '', true, false, 
    false, '', true, false, 
    false, '', '', '', '', true, 
    false, '', '', true
)
ON CONFLICT (category) DO NOTHING;

-- Add initial default advanced settings
INSERT INTO settings (
    category, 
    api_enabled, api_rate_limit_per_hour, api_rate_limit_window_minutes, enable_api_documentation,
    max_login_attempts, password_expiry_days, session_timeout_minutes, enforce_mfa,
    cache_duration_minutes, max_concurrent_file_uploads,
    enable_custom_fields, max_custom_fields_per_ticket,
    enable_ai_suggestions, enable_auto_tagging, enable_sentiment_analysis,
    ai_model_name
) 
VALUES (
    'advanced', 
    true, 1000, 15, true, 
    5, 90, 60, false, 
    15, 5, 
    true, 10, 
    true, true, true, 
    'gpt-3.5-turbo'
)
ON CONFLICT (category) DO NOTHING;

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_tickets_requester_id ON tickets(requester_id);
CREATE INDEX IF NOT EXISTS idx_tickets_assignee_id ON tickets(assignee_id);
CREATE INDEX IF NOT EXISTS idx_tickets_status_id ON tickets(status_id);
CREATE INDEX IF NOT EXISTS idx_tickets_organization_id ON tickets(organization_id);
CREATE INDEX IF NOT EXISTS idx_users_organization_id ON users(organization_id);
CREATE INDEX IF NOT EXISTS idx_user_tokens_user_id ON user_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_ticket_comments_ticket_id ON ticket_comments(ticket_id);
CREATE INDEX IF NOT EXISTS idx_kb_articles_category_id ON kb_articles(category_id);
CREATE INDEX IF NOT EXISTS idx_kb_articles_organization_id ON kb_articles(organization_id);
CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_is_read ON notifications(is_read);
CREATE INDEX IF NOT EXISTS idx_notifications_is_deleted ON notifications(is_deleted);
CREATE INDEX IF NOT EXISTS idx_chatbot_messages_conversation_id ON chatbot_messages(conversation_id);
CREATE INDEX IF NOT EXISTS idx_chatbot_conversations_user_id ON chatbot_conversations(user_id);
CREATE INDEX IF NOT EXISTS idx_sla_policy_tickets_ticket_id ON sla_policy_tickets(ticket_id);

-- Add text search index for knowledge base
CREATE INDEX IF NOT EXISTS idx_kb_articles_search ON kb_articles USING GIN(ai_search_vector);

-- Functions for SLA handling
CREATE OR REPLACE FUNCTION get_or_create_sla_policy_for_ticket(ticket_id BIGINT)
RETURNS BIGINT AS $$
DECLARE
    ticket_record RECORD;
    priority_record RECORD;
    sla_policy_id BIGINT;
    org_id BIGINT;
BEGIN
    -- Get ticket info
    SELECT t.id, t.priority_id, t.organization_id 
    INTO ticket_record
    FROM tickets t
    WHERE t.id = ticket_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Ticket not found: %', ticket_id;
    END IF;
    
    org_id := ticket_record.organization_id;
    
    -- Get priority info
    SELECT p.id, p.name, p.sla_hours
    INTO priority_record
    FROM ticket_priorities p
    WHERE p.id = ticket_record.priority_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Priority not found for ticket: %', ticket_id;
    END IF;
    
    -- Get existing SLA policy or create a new one
    SELECT id INTO sla_policy_id
    FROM sla_policies
    WHERE organization_id = org_id AND ticket_priority_id = priority_record.id;
    
    IF NOT FOUND THEN
        -- Create default SLA policy for this priority
        INSERT INTO sla_policies (
            name,
            description,
            organization_id,
            ticket_priority_id,
            first_response_hours,
            next_response_hours,
            resolution_hours,
            business_hours_only
        )
        VALUES (
            priority_record.name || ' Priority SLA',
            'Default SLA policy for ' || priority_record.name || ' priority tickets',
            org_id,
            priority_record.id,
            GREATEST(1, priority_record.sla_hours / 4),
            GREATEST(2, priority_record.sla_hours / 2),
            priority_record.sla_hours,
            TRUE
        )
        RETURNING id INTO sla_policy_id;
    END IF;
    
    RETURN sla_policy_id;
END;
$$ LANGUAGE plpgsql;

-- Triggers for updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP AT TIME ZONE 'UTC';
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Function to add default settings (departments, statuses, priorities, types) for a new organization
CREATE OR REPLACE FUNCTION add_organization_defaults()
RETURNS TRIGGER AS $$
DECLARE
  -- Default Departments
  default_departments text[][] := '{{"IT Support", "Handles technical issues and hardware/software support."},
                                {"Customer Service", "Handles customer inquiries and general support."},
                                {"Sales", "Handles sales-related inquiries."},
                                {"Billing", "Handles billing questions and issues."},
                                {"Human Resources", "Handles internal HR matters."}}';
  -- Default Ticket Statuses (Matches initialize_database.js)
  default_statuses text[][] := '{{"Open", "#1E88E5", "TRUE", "FALSE"},
                                {"In Progress", "#7B1FA2", "FALSE", "FALSE"},
                                {"Pending", "#FFC107", "FALSE", "FALSE"},
                                {"Resolved", "#43A047", "FALSE", "TRUE"},
                                {"Closed", "#757575", "FALSE", "TRUE"}}';
  -- Default Ticket Priorities (Matches initialize_database.js)
  default_priorities text[][] := '{{"Low", "#1E88E5", "48"},
                                 {"Medium", "#FFC107", "24"},
                                 {"High", "#FF5722", "8"},
                                 {"Urgent", "#D32F2F", "4"}}';
  -- Default Ticket Types (Matches initialize_database.js)
  default_types text[][] :=      '{{"Question", "General questions about using the service"},
                                {"Incident", "Service disruption or error"},
                                {"Problem", "Underlying issue causing one or more incidents"},
                                {"Feature Request", "Request for new functionality"},
                                {"Bug", "Report of system not working as expected"}}';
  -- Default Tags (from CreateTicketPage.tsx)
  default_tags text[] := '{hardware,software,network,email,printer,security,access,mobile,desktop,authentication,vpn,database,application,server,microsoft365,windows,mac,linux,password,wifi}';
  item text[];
  tag_name text;
  default_tag_color text := '#808080'; -- Default color for tags
  priority_id BIGINT;
  priority_name text;
  priority_sla_hours integer;
BEGIN
  -- Insert Departments
  FOREACH item SLICE 1 IN ARRAY default_departments
  LOOP
    INSERT INTO departments (organization_id, name, description)
    VALUES (NEW.id, item[1], item[2])
    ON CONFLICT (organization_id, name) DO NOTHING;
  END LOOP;
  
  -- Insert Ticket Statuses (with explicit check)
  FOREACH item SLICE 1 IN ARRAY default_statuses
  LOOP
    -- Check if a status with this name already exists for this org
    IF NOT EXISTS (SELECT 1 FROM ticket_statuses 
                   WHERE organization_id = NEW.id AND name = item[1])
    THEN
        -- Insert with is_default always FALSE; will be set manually for default org
        INSERT INTO ticket_statuses (organization_id, name, color, is_default, is_resolved)
        VALUES (NEW.id, item[1], item[2], FALSE, item[4]::boolean);
    END IF;
  END LOOP;

  -- Insert Ticket Priorities
  FOREACH item SLICE 1 IN ARRAY default_priorities
  LOOP
    INSERT INTO ticket_priorities (organization_id, name, color, sla_hours)
    VALUES (NEW.id, item[1], item[2], item[3]::integer)
    ON CONFLICT (organization_id, name) DO NOTHING;
  END LOOP;

  -- Insert Ticket Types
  FOREACH item SLICE 1 IN ARRAY default_types
  LOOP
    INSERT INTO ticket_types (organization_id, name, description)
    VALUES (NEW.id, item[1], item[2])
    ON CONFLICT (organization_id, name) DO NOTHING;
  END LOOP;

  -- Insert Tags
  FOREACH tag_name IN ARRAY default_tags
  LOOP
    INSERT INTO tags (organization_id, name, color)
    VALUES (NEW.id, tag_name, default_tag_color)
    ON CONFLICT (organization_id, name) DO NOTHING; -- Assuming UNIQUE constraint on (organization_id, name)
  END LOOP;

  -- Create default SLA policies for each priority
  FOREACH item SLICE 1 IN ARRAY default_priorities
  LOOP
    priority_name := item[1];
    priority_sla_hours := item[3]::integer;
    
    -- Get the ID of the priority we just created
    SELECT id INTO priority_id FROM ticket_priorities 
    WHERE organization_id = NEW.id AND name = priority_name;
    
    IF FOUND THEN
      -- Create an SLA policy for this priority
      INSERT INTO sla_policies (
        name, 
        description, 
        organization_id, 
        ticket_priority_id, 
        first_response_hours, 
        next_response_hours, 
        resolution_hours, 
        business_hours_only
      )
      VALUES (
        priority_name || ' Priority SLA',
        'Default SLA policy for ' || priority_name || ' priority tickets',
        NEW.id,
        priority_id,
        GREATEST(1, priority_sla_hours / 4),  -- First response is 1/4 of total time, but minimum 1 hour
        GREATEST(2, priority_sla_hours / 2),  -- Next response is 1/2 of total time, but minimum 2 hours
        priority_sla_hours,                   -- Resolution time is the full SLA hours
        TRUE                                  -- Default to business hours only
      )
      ON CONFLICT (organization_id, ticket_priority_id) DO NOTHING;
    END IF;
  END LOOP;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to call the function after an organization is inserted
DROP TRIGGER IF EXISTS trg_add_default_departments ON organizations; -- Drop old trigger first
CREATE TRIGGER trg_add_organization_defaults -- Renamed trigger
AFTER INSERT ON organizations
FOR EACH ROW
EXECUTE FUNCTION add_organization_defaults(); -- Call renamed function

-- Apply trigger function to all relevant tables for updated_at column
DO $$ 
DECLARE 
  tbl_name text;
BEGIN
  FOR tbl_name IN 
    SELECT table_name 
    FROM information_schema.columns 
    WHERE table_schema = 'public' -- Or your specific schema
      AND column_name = 'updated_at'
      AND table_name NOT IN (
        -- List tables that should NOT have the trigger, if any
        'some_table_without_auto_update'
      )
  LOOP
    EXECUTE format('DROP TRIGGER IF EXISTS update_%1$s_modtime ON %1$s;', tbl_name);
    EXECUTE format('CREATE TRIGGER update_%1$s_modtime BEFORE UPDATE ON %1$s FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();', tbl_name);
  END LOOP;
END $$;

-- Business Hours table
CREATE TABLE IF NOT EXISTS business_hours (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  organization_id BIGINT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  monday_start VARCHAR(5), -- '09:00' format
  monday_end VARCHAR(5),
  tuesday_start VARCHAR(5),
  tuesday_end VARCHAR(5),
  wednesday_start VARCHAR(5),
  wednesday_end VARCHAR(5),
  thursday_start VARCHAR(5),
  thursday_end VARCHAR(5),
  friday_start VARCHAR(5),
  friday_end VARCHAR(5),
  saturday_start VARCHAR(5),
  saturday_end VARCHAR(5),
  sunday_start VARCHAR(5),
  sunday_end VARCHAR(5),
  is_default BOOLEAN DEFAULT FALSE,
  timezone VARCHAR(50) DEFAULT 'UTC',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  EXCLUDE USING gist (organization_id WITH =) WHERE (is_default)
);

-- Holidays table
CREATE TABLE IF NOT EXISTS holidays (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1001 INCREMENT BY 1),
  name VARCHAR(255) NOT NULL,
  date DATE NOT NULL,
  business_hours_id BIGINT NOT NULL REFERENCES business_hours(id) ON DELETE CASCADE,
  recurring BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Insert default business hours for each organization
INSERT INTO business_hours (name, description, organization_id, monday_start, monday_end, tuesday_start, tuesday_end, wednesday_start, wednesday_end, thursday_start, thursday_end, friday_start, friday_end, is_default, timezone)
SELECT 'Standard Business Hours', 'Monday to Friday, 9 AM to 5 PM', id, '09:00', '17:00', '09:00', '17:00', '09:00', '17:00', '09:00', '17:00', '09:00', '17:00', TRUE, 'UTC'
FROM organizations
WHERE NOT EXISTS (
  SELECT 1 FROM business_hours WHERE organization_id = organizations.id
);

-- Create default SLA policies for existing organizations
DO $$
DECLARE
  org_record RECORD;
  priority_record RECORD;
BEGIN
  -- Loop through each organization
  FOR org_record IN SELECT id FROM organizations
  LOOP
    -- For each organization, check its priorities and create SLA policies if needed
    FOR priority_record IN SELECT id, name, sla_hours 
                           FROM ticket_priorities 
                           WHERE organization_id = org_record.id
    LOOP
      -- Skip if SLA policy already exists for this priority
      IF NOT EXISTS (
        SELECT 1 FROM sla_policies 
        WHERE organization_id = org_record.id AND ticket_priority_id = priority_record.id
      ) THEN
        -- Create default SLA policy for this priority
        INSERT INTO sla_policies (
          name,
          description,
          organization_id,
          ticket_priority_id,
          first_response_hours,
          next_response_hours,
          resolution_hours,
          business_hours_only
        )
        VALUES (
          priority_record.name || ' Priority SLA',
          'Default SLA policy for ' || priority_record.name || ' priority tickets',
          org_record.id,
          priority_record.id,
          GREATEST(1, priority_record.sla_hours / 4),  -- First response: 1/4 of total time, min 1 hour
          GREATEST(2, priority_record.sla_hours / 2),  -- Next response: 1/2 of total time, min 2 hours
          priority_record.sla_hours,                   -- Resolution time is the full SLA hours
          TRUE                                         -- Default to business hours only
        );
      END IF;
    END LOOP;
  END LOOP;
END $$;

-- Create a function that gets or creates an SLA policy for a priority directly
-- This is used by the controller to avoid foreign key issues
CREATE OR REPLACE FUNCTION get_or_create_sla_policy_for_priority(
    p_priority_id BIGINT,
    p_org_id BIGINT
)
RETURNS BIGINT AS $$
DECLARE
    priority_record RECORD;
    sla_policy_id BIGINT;
BEGIN
    -- Get priority info
    SELECT p.id, p.name, p.sla_hours
    INTO priority_record
    FROM ticket_priorities p
    WHERE p.id = p_priority_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Priority not found with ID: %', p_priority_id;
    END IF;
    
    -- Get existing SLA policy or create a new one
    SELECT id INTO sla_policy_id
    FROM sla_policies
    WHERE organization_id = p_org_id AND ticket_priority_id = p_priority_id;
    
    IF NOT FOUND OR sla_policy_id IS NULL THEN
        -- Create default SLA policy for this priority
        INSERT INTO sla_policies (
            name,
            description,
            organization_id,
            ticket_priority_id,
            first_response_hours,
            next_response_hours,
            resolution_hours,
            business_hours_only
        )
        VALUES (
            priority_record.name || ' Priority SLA',
            'Default SLA policy for ' || priority_record.name || ' priority tickets',
            p_org_id,
            p_priority_id,
            GREATEST(1, priority_record.sla_hours / 4),
            GREATEST(2, priority_record.sla_hours / 2),
            priority_record.sla_hours,
            TRUE
        )
        RETURNING id INTO sla_policy_id;
    END IF;
    
    RETURN sla_policy_id;
END;
$$ LANGUAGE plpgsql;

-- Function to fix SLA data for existing tickets
CREATE OR REPLACE FUNCTION fix_all_sla_data()
RETURNS VOID AS $$
DECLARE
    ticket_record RECORD;
    sla_policy_record RECORD;
    ticket_metadata JSONB;
    resolution_due TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Loop through all SLA policy tickets without metadata
    FOR ticket_record IN
        SELECT t.*, spt.id AS sla_policy_ticket_id, spt.sla_policy_id
        FROM sla_policy_tickets spt
        JOIN tickets t ON t.id = spt.ticket_id
        WHERE spt.metadata IS NULL OR t.due_date IS NULL
        ORDER BY t.id
    LOOP
        -- Get policy details
        SELECT * INTO sla_policy_record
        FROM sla_policies
        WHERE id = ticket_record.sla_policy_id;
        
        IF FOUND THEN
            -- Calculate resolution due date
            resolution_due := ticket_record.created_at + (sla_policy_record.resolution_hours || ' hours')::interval;
            
            -- Create JSON metadata for ticket information
            ticket_metadata := jsonb_build_object(
                'ticket_id', ticket_record.id,
                'subject', ticket_record.subject,
                'priority_id', ticket_record.priority_id,
                'type_id', ticket_record.type_id,
                'department_id', ticket_record.department_id,
                'requester_id', ticket_record.requester_id,
                'assignee_id', ticket_record.assignee_id,
                'created_at', ticket_record.created_at,
                'sla_policy', jsonb_build_object(
                    'id', sla_policy_record.id,
                    'name', sla_policy_record.name,
                    'first_response_hours', sla_policy_record.first_response_hours,
                    'next_response_hours', sla_policy_record.next_response_hours,
                    'resolution_hours', sla_policy_record.resolution_hours,
                    'business_hours_only', sla_policy_record.business_hours_only
                ),
                'pausePeriods', jsonb_build_array(),
                'totalPausedTime', 0
            );
            
            -- Update SLA policy ticket with metadata
            UPDATE sla_policy_tickets
            SET metadata = ticket_metadata
            WHERE id = ticket_record.sla_policy_ticket_id;
            
            -- Update ticket with due_date and sla_status
            UPDATE tickets
            SET due_date = resolution_due, sla_status = 'active'
            WHERE id = ticket_record.id;
        END IF;
    END LOOP;
    
    RAISE NOTICE 'SLA data fix completed';
END;
$$ LANGUAGE plpgsql;

-- Function to update a ticket due date based on priority
CREATE OR REPLACE FUNCTION update_ticket_due_date()
RETURNS TRIGGER AS $$
DECLARE
    priority_record RECORD;
    sla_hours INT;
    resolution_due TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Only proceed if priority is set
    IF NEW.priority_id IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Get priority details
    SELECT p.sla_hours
    INTO priority_record
    FROM ticket_priorities p
    WHERE p.id = NEW.priority_id;
    
    IF FOUND THEN
        -- Calculate resolution due date directly from SLA hours
        resolution_due := NEW.created_at + (priority_record.sla_hours || ' hours')::interval;
        
        -- Update the NEW record's due_date directly (works in BEFORE triggers)
        NEW.due_date := resolution_due;
        NEW.sla_status := 'active';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to create a utility function to fix SLA policy tickets for all tickets
CREATE OR REPLACE FUNCTION fix_missing_sla_policy_tickets()
RETURNS VOID AS $$
DECLARE
  ticket_record RECORD;
BEGIN
  -- Loop through all tickets that don't have an SLA policy ticket
  FOR ticket_record IN 
    SELECT 
      t.id, 
      t.created_at, 
      t.priority_id,
      t.organization_id 
    FROM tickets t
    LEFT JOIN sla_policy_tickets spt ON t.id = spt.ticket_id
    WHERE spt.id IS NULL AND t.priority_id IS NOT NULL
  LOOP
    -- Manual fix for each ticket
    DECLARE
      sla_policy_id BIGINT;
      policy_record RECORD;
      first_response_due TIMESTAMP WITH TIME ZONE;
      next_response_due TIMESTAMP WITH TIME ZONE;
      resolution_due TIMESTAMP WITH TIME ZONE;
    BEGIN
      -- Get or create SLA policy
      sla_policy_id := get_or_create_sla_policy_for_ticket(ticket_record.id);
      
      -- Get policy details
      SELECT * INTO policy_record
      FROM sla_policies
      WHERE id = sla_policy_id;
      
      -- Calculate due dates
      IF policy_record.business_hours_only THEN
        -- This would normally use business hours calculation - simplified here
        first_response_due := ticket_record.created_at + (policy_record.first_response_hours || ' hours')::interval;
        next_response_due := ticket_record.created_at + (policy_record.next_response_hours || ' hours')::interval;
        resolution_due := ticket_record.created_at + (policy_record.resolution_hours || ' hours')::interval;
      ELSE
        first_response_due := ticket_record.created_at + (policy_record.first_response_hours || ' hours')::interval;
        next_response_due := ticket_record.created_at + (policy_record.next_response_hours || ' hours')::interval;
        resolution_due := ticket_record.created_at + (policy_record.resolution_hours || ' hours')::interval;
      END IF;
      
      -- Create SLA policy ticket
      INSERT INTO sla_policy_tickets (
        ticket_id,
        sla_policy_id,
        first_response_due_at,
        next_response_due_at,
        resolution_due_at,
        first_response_met,
        next_response_met,
        resolution_met
      )
      VALUES (
        ticket_record.id,
        sla_policy_id,
        first_response_due,
        next_response_due,
        resolution_due,
        FALSE,
        FALSE,
        FALSE
      )
      ON CONFLICT (ticket_id) DO NOTHING;
      
      -- Update ticket with SLA status
      UPDATE tickets
      SET sla_status = 'active'
      WHERE id = ticket_record.id;
    END;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Function to reassign SLA policy when ticket priority changes
CREATE OR REPLACE FUNCTION reassign_sla_on_priority_change()
RETURNS TRIGGER AS $$
DECLARE
  new_sla_policy_id BIGINT;
  current_policy_id BIGINT;
  policy_record RECORD;
  first_response_due TIMESTAMP WITH TIME ZONE;
  next_response_due TIMESTAMP WITH TIME ZONE;
  resolution_due TIMESTAMP WITH TIME ZONE;
  status_is_pending BOOLEAN;
  status_is_resolved BOOLEAN;
  is_breached BOOLEAN;
BEGIN
  -- Only run if priority has changed
  IF OLD.priority_id IS DISTINCT FROM NEW.priority_id THEN
    -- If priority is now NULL, deactivate SLA
    IF NEW.priority_id IS NULL THEN
      NEW.sla_status := 'inactive';
      RETURN NEW;
    END IF;
    
    -- Get SLA policy for this priority and organization
    SELECT sp.id INTO new_sla_policy_id
    FROM sla_policies sp
    WHERE sp.organization_id = NEW.organization_id AND sp.ticket_priority_id = NEW.priority_id;
    
    -- If no policy found, create one
    IF NOT FOUND OR new_sla_policy_id IS NULL THEN
      BEGIN
        new_sla_policy_id := get_or_create_sla_policy_for_priority(NEW.priority_id, NEW.organization_id);
      EXCEPTION WHEN OTHERS THEN
        RAISE NOTICE 'Failed to create SLA policy for ticket % with priority %: %', NEW.id, NEW.priority_id, SQLERRM;
        NEW.sla_status := 'inactive';
        RETURN NEW;
      END;
    END IF;
    
    -- Check if the ticket already has an SLA policy assigned
    SELECT spt.sla_policy_id INTO current_policy_id
    FROM sla_policy_tickets spt
    WHERE spt.ticket_id = NEW.id;
    
    -- If ticket already has this exact policy, no need to update
    IF FOUND AND current_policy_id = new_sla_policy_id THEN
      RAISE NOTICE 'Ticket % already has SLA policy % assigned', NEW.id, new_sla_policy_id;
      -- Update ticket's SLA status to ensure correct status
      NEW.sla_status := COALESCE(NEW.sla_status, 'active');
      RETURN NEW;
    END IF;
    
    -- Get policy details
    SELECT * INTO policy_record
    FROM sla_policies
    WHERE id = new_sla_policy_id;
    
    IF NOT FOUND THEN
      -- Policy not found, log an error but continue
      RAISE NOTICE 'SLA policy % not found for ticket % with priority %', new_sla_policy_id, NEW.id, NEW.priority_id;
      NEW.sla_status := 'inactive';
      RETURN NEW;
    END IF;
    
    -- Calculate due dates
    first_response_due := NEW.created_at + (policy_record.first_response_hours || ' hours')::interval;
    next_response_due := NEW.created_at + (policy_record.next_response_hours || ' hours')::interval;
    resolution_due := NEW.created_at + (policy_record.resolution_hours || ' hours')::interval;
    
    -- Update due date on ticket
    NEW.due_date := resolution_due;
    
    -- If an SLA policy ticket exists, update it, otherwise create a new one
    IF current_policy_id IS NOT NULL THEN
      UPDATE sla_policy_tickets
      SET 
        sla_policy_id = new_sla_policy_id,
        first_response_due_at = first_response_due,
        next_response_due_at = next_response_due,
        resolution_due_at = resolution_due
      WHERE ticket_id = NEW.id;
      
      RAISE NOTICE 'Updated SLA policy for ticket % from % to %', NEW.id, current_policy_id, new_sla_policy_id;
    ELSE
      INSERT INTO sla_policy_tickets (
        ticket_id,
        sla_policy_id,
        first_response_due_at,
        next_response_due_at,
        resolution_due_at,
        first_response_met,
        next_response_met,
        resolution_met
      )
      VALUES (
        NEW.id,
        new_sla_policy_id,
        first_response_due,
        next_response_due,
        resolution_due,
        FALSE,
        FALSE,
        FALSE
      );
      
      RAISE NOTICE 'Created new SLA policy ticket for ticket % with policy %', NEW.id, new_sla_policy_id;
    END IF;
    
    -- Update ticket with SLA status
    NEW.sla_status := 'active';
  END IF;
  
  -- Manually calculate SLA status rather than calling update_ticket_sla_status
  -- Check if status is pending or resolved
  status_is_pending := is_pending_status(NEW.status_id);
  status_is_resolved := NOT is_active_status(NEW.status_id);
  is_breached := COALESCE(NEW.resolution_sla_breached, FALSE);
  
  -- Set SLA status based on current conditions
  NEW.sla_status := get_sla_status_text(
    is_breached,
    status_is_resolved,
    status_is_pending,
    NEW.priority_id IS NULL
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to update ticket SLA status
CREATE OR REPLACE FUNCTION update_ticket_sla_status()
RETURNS TRIGGER AS $$
DECLARE
  status_is_resolved BOOLEAN;
  status_is_pending BOOLEAN;
  status_text VARCHAR;
BEGIN
  -- Check if priority is null
  IF NEW.priority_id IS NULL THEN
    NEW.sla_status := 'inactive';
    RETURN NEW;
  END IF;
  
  -- Check if status is resolved
  SELECT ts.is_resolved INTO status_is_resolved
  FROM ticket_statuses ts
  WHERE ts.id = NEW.status_id;
  
  -- Check if status is pending
  status_is_pending := is_pending_status(NEW.status_id);
  
  -- Get SLA status text
  status_text := get_sla_status_text(
    COALESCE(NEW.resolution_sla_breached, FALSE),
    status_is_resolved,
    status_is_pending,
    FALSE  -- priority is not null
  );
  
  NEW.sla_status := status_text;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to update SLA status for multiple tickets
CREATE OR REPLACE FUNCTION update_tickets_sla_status()
RETURNS VOID AS $$
DECLARE
  ticket_record RECORD;
BEGIN
  FOR ticket_record IN 
    SELECT t.* 
    FROM tickets t
    WHERE t.priority_id IS NOT NULL
  LOOP
    -- Update SLA breaches
    PERFORM check_sla_breaches(ticket_record.id);
    
    -- Update SLA status using direct calculation rather than calling the trigger function
    UPDATE tickets
    SET sla_status = (
      SELECT get_sla_status_text(
        COALESCE(t.resolution_sla_breached, FALSE),
        ts.is_resolved,
        is_pending_status(t.status_id),
        t.priority_id IS NULL
      )
      FROM tickets t
      JOIN ticket_statuses ts ON t.status_id = ts.id
      WHERE t.id = ticket_record.id
    )
    WHERE id = ticket_record.id;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Function to check SLA breaches
CREATE OR REPLACE FUNCTION check_sla_breaches(p_ticket_id BIGINT)
RETURNS VOID AS $$
DECLARE
  sla_record RECORD;
  current_time TIMESTAMP WITH TIME ZONE := CURRENT_TIMESTAMP;
BEGIN
  -- Get SLA policy ticket
  SELECT * INTO sla_record
  FROM sla_policy_tickets
  WHERE ticket_id = p_ticket_id;
  
  IF FOUND THEN
    -- Check for first response breach
    IF sla_record.first_response_due_at < current_time AND sla_record.first_response_met IS NULL THEN
      UPDATE tickets SET first_response_sla_breached = TRUE WHERE id = p_ticket_id;
    END IF;
    
    -- Check for resolution breach
    IF sla_record.resolution_due_at < current_time AND sla_record.resolution_met IS NULL THEN
      UPDATE tickets SET resolution_sla_breached = TRUE WHERE id = p_ticket_id;
    END IF;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to check if a status is a pending status
CREATE OR REPLACE FUNCTION is_pending_status(p_status_id BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
  status_name VARCHAR;
  is_pending BOOLEAN := FALSE;
BEGIN
  -- Get the status name
  SELECT name INTO status_name
  FROM ticket_statuses
  WHERE id = p_status_id;
  
  IF FOUND THEN
    status_name := LOWER(status_name);
    
    -- Check for common pending status names
    IF status_name LIKE '%pending%' OR 
       status_name LIKE '%awaiting%' OR 
       status_name LIKE '%waiting%' OR 
       status_name LIKE '%on hold%' OR
       status_name LIKE '%customer response%' THEN
      is_pending := TRUE;
    END IF;
  END IF;
  
  RETURN is_pending;
END;
$$ LANGUAGE plpgsql;

-- Function to check if a status is an active status
CREATE OR REPLACE FUNCTION is_active_status(p_status_id BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
  status_record RECORD;
BEGIN
  -- Get the status
  SELECT * INTO status_record
  FROM ticket_statuses
  WHERE id = p_status_id;
  
  IF FOUND THEN
    -- Not resolved and not pending = active
    RETURN NOT status_record.is_resolved AND NOT is_pending_status(p_status_id);
  END IF;
  
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- Function to get SLA status text
CREATE OR REPLACE FUNCTION get_sla_status_text(
  is_breached BOOLEAN,
  is_resolved BOOLEAN,
  is_pending BOOLEAN,
  no_priority BOOLEAN
)
RETURNS VARCHAR AS $$
BEGIN
  IF no_priority THEN
    RETURN 'inactive';
  ELSIF is_resolved THEN
    RETURN CASE WHEN is_breached THEN 'breached' ELSE 'completed' END;
  ELSIF is_pending THEN
    RETURN 'paused';
  ELSIF is_breached THEN
    RETURN 'breached';
  ELSE
    RETURN 'active';
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to handle SLA pause when status changes
CREATE OR REPLACE FUNCTION handle_sla_pause_on_status_change()
RETURNS TRIGGER AS $$
DECLARE
  old_is_pending BOOLEAN;
  new_is_pending BOOLEAN;
  sla_record RECORD;
  metadata JSONB;
  pause_periods JSONB;
BEGIN
  -- Check if we should update SLA pause state
  old_is_pending := is_pending_status(OLD.status_id);
  new_is_pending := is_pending_status(NEW.status_id);
  
  -- Only continue if pause state is changing
  IF old_is_pending = new_is_pending THEN
    RETURN NEW;
  END IF;
  
  -- Get SLA record
  SELECT * INTO sla_record
  FROM sla_policy_tickets
  WHERE ticket_id = NEW.id;
  
  IF NOT FOUND THEN
    -- No SLA record to update
    RETURN NEW;
  END IF;
  
  -- Initialize metadata if doesn't exist
  IF sla_record.metadata IS NULL THEN
    metadata := jsonb_build_object(
      'pausePeriods', jsonb_build_array(),
      'totalPausedTime', 0
    );
  ELSE
    metadata := sla_record.metadata;
  END IF;
  
  -- Extract pause periods array
  IF metadata ? 'pausePeriods' THEN
    pause_periods := metadata->'pausePeriods';
  ELSE
    pause_periods := jsonb_build_array();
  END IF;
  
  -- If changing to pending, add new pause period
  IF new_is_pending AND NOT old_is_pending THEN
    -- Add new pause start
    pause_periods := pause_periods || jsonb_build_object(
      'startedAt', CURRENT_TIMESTAMP,
      'endedAt', NULL
    );
    
    -- Update metadata
    metadata := jsonb_set(metadata, '{pausePeriods}', pause_periods);
    
    -- Update SLA record
    UPDATE sla_policy_tickets
    SET metadata = metadata
    WHERE id = sla_record.id;
    
    -- Update ticket SLA status
    NEW.sla_status := 'paused';
  
  -- If changing from pending to active, update the last pause period
  ELSIF old_is_pending AND NOT new_is_pending THEN
    -- Only update if there are pause periods and the last one is still open
    IF jsonb_array_length(pause_periods) > 0 THEN
      DECLARE
        idx INTEGER := jsonb_array_length(pause_periods) - 1;
        last_pause JSONB := pause_periods->idx;
      BEGIN
        -- Check if the last pause doesn't have an end time
        IF last_pause ? 'startedAt' AND (NOT last_pause ? 'endedAt' OR last_pause->>'endedAt' IS NULL) THEN
          -- Calculate pause duration in minutes
          DECLARE
            pause_start TIMESTAMP WITH TIME ZONE := (last_pause->>'startedAt')::TIMESTAMP WITH TIME ZONE;
            current_time TIMESTAMP WITH TIME ZONE := CURRENT_TIMESTAMP;
            pause_duration_minutes INTEGER;
            total_paused_time INTEGER;
          BEGIN
            pause_duration_minutes := EXTRACT(EPOCH FROM (current_time - pause_start)) / 60;
            
            -- Update the last pause period with end time
            pause_periods := jsonb_set(
              pause_periods, 
              ARRAY[idx::text], 
              jsonb_set(last_pause, '{endedAt}', to_jsonb(current_time))
            );
            
            -- Update total paused time
            IF metadata ? 'totalPausedTime' THEN
              total_paused_time := (metadata->>'totalPausedTime')::INTEGER + pause_duration_minutes;
            ELSE
              total_paused_time := pause_duration_minutes;
            END IF;
            
            metadata := jsonb_set(metadata, '{pausePeriods}', pause_periods);
            metadata := jsonb_set(metadata, '{totalPausedTime}', to_jsonb(total_paused_time));
            
            -- Update SLA record with new metadata
            UPDATE sla_policy_tickets
            SET metadata = metadata
            WHERE id = sla_record.id;
            
            -- Also extend the due dates by the pause duration
            IF pause_duration_minutes > 0 THEN
              UPDATE sla_policy_tickets
              SET 
                first_response_due_at = first_response_due_at + (pause_duration_minutes || ' minutes')::interval,
                next_response_due_at = next_response_due_at + (pause_duration_minutes || ' minutes')::interval,
                resolution_due_at = resolution_due_at + (pause_duration_minutes || ' minutes')::interval
              WHERE id = sla_record.id;
              
              -- Also update the ticket due date
              NEW.due_date := NEW.due_date + (pause_duration_minutes || ' minutes')::interval;
            END IF;
          END;
        END IF;
      END;
    END IF;
    
    -- Update ticket SLA status
    NEW.sla_status := 'active';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for SLA handling
DROP TRIGGER IF EXISTS update_ticket_sla_status_trigger ON tickets;
CREATE TRIGGER update_ticket_sla_status_trigger
BEFORE UPDATE OF status_id ON tickets
FOR EACH ROW
EXECUTE FUNCTION update_ticket_sla_status();

DROP TRIGGER IF EXISTS reassign_sla_on_priority_change_trigger ON tickets;
CREATE TRIGGER reassign_sla_on_priority_change_trigger
BEFORE UPDATE OF priority_id ON tickets
FOR EACH ROW
EXECUTE FUNCTION reassign_sla_on_priority_change();

DROP TRIGGER IF EXISTS handle_sla_pause_on_status_change_trigger ON tickets;
CREATE TRIGGER handle_sla_pause_on_status_change_trigger
BEFORE UPDATE OF status_id ON tickets
FOR EACH ROW
WHEN (OLD.status_id IS DISTINCT FROM NEW.status_id)
EXECUTE FUNCTION handle_sla_pause_on_status_change();

-- Function to add default notification preferences when a new user is created
CREATE OR REPLACE FUNCTION add_default_notification_preferences()
RETURNS TRIGGER AS $$
DECLARE
  -- Default notification types with their channel settings
  default_types TEXT[][] := '{
    {"newTicketAssigned", TRUE, TRUE, TRUE},
    {"ticketUpdated", TRUE, TRUE, FALSE}, 
    {"mentionInComment", TRUE, TRUE, TRUE},
    {"newKbArticle", FALSE, TRUE, FALSE},
    {"systemUpdates", TRUE, TRUE, FALSE},
    {"ticketDueReminder", TRUE, TRUE, FALSE},
    {"ticketEscalation", TRUE, TRUE, TRUE}
  }';
  notification_type TEXT[];
BEGIN
  -- For each notification type, create default preferences
  FOREACH notification_type SLICE 1 IN ARRAY default_types
  LOOP
    INSERT INTO notification_preferences (
      user_id, 
      event_type, 
      email_enabled, 
      in_app_enabled, 
      push_enabled,
      created_at,
      updated_at
    )
    VALUES (
      NEW.id,
      notification_type[1],
      notification_type[2]::BOOLEAN,
      notification_type[3]::BOOLEAN,
      notification_type[4]::BOOLEAN,
      CURRENT_TIMESTAMP,
      CURRENT_TIMESTAMP
    );
  END LOOP;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to call function after user insert
DROP TRIGGER IF EXISTS trg_add_default_notification_preferences ON users;
CREATE TRIGGER trg_add_default_notification_preferences
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION add_default_notification_preferences();